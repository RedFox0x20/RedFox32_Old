#include <Kernel/IO.h>
#
#define IDT_ENTRY_COUNT 256

struct IDT_Entry
{
	unsigned short OffsetLow;
	unsigned short Selector;
	unsigned char Zero;
	unsigned char TypeAttributes;
	unsigned short OffsetHigh;
} __attribute__((packed));

struct IDT_Pointer
{
	unsigned short Limit;
	void *Ptr;
} __attribute__((packed));

static struct IDT_Entry IDT[IDT_ENTRY_COUNT];

void (*InterruptHandlers[16])(void);

extern void
	Int_0(void),
	Int_1(void),
	Int_2(void),
	Int_3(void),
	Int_4(void),
	Int_5(void),
	Int_6(void),
	Int_7(void),
	Int_8(void),
	Int_9(void),
	Int_10(void),
	Int_11(void),
	Int_12(void),
	Int_13(void),
	Int_14(void),
	Int_15(void);

const void (*Interrupts[16])(void) = 
{
	Int_0,
	Int_1,
	Int_2,
	Int_3,
	Int_4,
	Int_5,
	Int_6,
	Int_7,
	Int_8,
	Int_9,
	Int_10,
	Int_11,
	Int_12,
	Int_13,
	Int_14,
	Int_15
};

extern void SetIDT(struct IDT_Pointer*);

/* IDT_InitializePIC
 * Remaps the PIC mappings as we do not want to use the BIOS defaults
 */
static void IDT_InitializePIC(void)
{
	outb(0x20, 0x11);
	outb(0xA0, 0x11);
	outb(0x21, 0x20);
	outb(0xA1, 0x28);
	outb(0x21, 0x04);
	outb(0xA1, 0x02);
	outb(0x21, 0x01);
	outb(0xA1, 0x01);
	outb(0x21, 0x00);
	outb(0xA1, 0x00);
}

void DEBUG_KBD_INTERRUPT()
{
	((char*)0xB8000)[2] = 'I';
	inb(0x60);
}

/* IDT_SetInterruptEntry
 * Used to setup Interrupt Entries
 * unsigned int EID: The ID of the entry to modify, must be >= 32
 * void (*Func)(void): The function to be used by the interrupt.
 * Returns non zero on success. Value is the address of the entry filled.
 */
static unsigned int IDT_SetInterruptEntry(unsigned int EID, void (*Func)(void))
{
	if (EID < 32) return 0;

	struct IDT_Entry *Entry = &(IDT[EID]);
	Entry->OffsetLow  = 
		(unsigned short)((unsigned long)Func & 0x0000FFFF);
	Entry->OffsetHigh = 
		(unsigned short)((unsigned long)Func & 0xFFFF0000) >> 16;
	Entry->Zero = 0;
	Entry->TypeAttributes = 0x8E;
	Entry->Selector = 0x08;
	return (unsigned int)Entry;
}

void IDT_Setup(void)
{
	IDT_InitializePIC();
	for (unsigned int i = 0; i < 16; i++)
	{
		InterruptHandlers[i] = 0;
	}
	for (int i = 0; i < IDT_ENTRY_COUNT; i++)
	{
		IDT[i].OffsetLow = 0;
		IDT[i].OffsetHigh = 0;
		IDT[i].Zero = 0;
		IDT[i].Selector = 0;
		IDT[i].TypeAttributes = 0;
	}
	for (int i = 32; i < 48; i++)
	{
		IDT_SetInterruptEntry(i, Interrupts[i-32]);
	}
	InterruptHandlers[1] = DEBUG_KBD_INTERRUPT;
	struct IDT_Pointer IDTPtr = 
	{
		.Limit = (sizeof(struct IDT_Entry) * IDT_ENTRY_COUNT) - 1,
		.Ptr = IDT
	};


	SetIDT(&IDTPtr);
}

/* InterruptHandlerStub
 * The InterruptHandlerStub is a method of allowing the interrupt handlers to be
 * changed without having to reload the IDT every time, this also allows for the
 * use of regular function as generated by the compiler.
 * ID: The ID number with an offset of 32 to skip the system defined interrupts
 *     32+ID
 */
void InterruptHandlerStub(unsigned char ID)
{
	((char*)0xB8000)[0] = 'S';
	if (ID < 16)
	{
		void (*Func)(void) = (void (*)(void))InterruptHandlers[ID];
		if (Func !=0)
		{
			Func();
		}
	}
	if (ID >= 8)
	{
		outb(0xA0, 0x20);
	}
	outb(0x20, 0x20);
}

#undef IDT_ENTRY_COUNT
